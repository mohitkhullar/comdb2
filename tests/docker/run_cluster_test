#!/bin/bash

set -e

usage() {
    echo "Usage: $0 <testname> [options]"
    echo ""
    echo "Run a clustered test in Docker containers"
    echo ""
    echo "Arguments:"
    echo "  testname          Name of the test to run (e.g., remsql_auth_parallel)"
    echo ""
    echo "Options:"
    echo "  -n, --nodes NUM   Number of cluster nodes (default: 3)"
    echo "  -k, --keep        Keep containers running after test (for debugging)"
    echo "  --coverage        Enable code coverage"
    echo "  -h, --help        Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 remsql_auth_parallel"
    echo "  $0 remsql_auth_parallel -n 5"
    echo "  $0 remsql_auth_parallel --keep"
    echo ""
    echo "After --keep, inspect with:"
    echo "  docker logs c1              # view test output"
    echo "  docker exec -it c1 bash     # shell into client"
    echo "  $0 --cleanup                # remove containers"
    exit 1
}

cleanup() {
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    cd "$script_dir"
    echo "Cleaning up containers..."
    docker compose down --rmi all --volumes 2>/dev/null || true
    docker compose rm -f 2>/dev/null || true
    # Also stop any containers by name in case compose file is missing
    docker stop c1 m1 m2 m3 m4 m5 2>/dev/null || true
    docker rm c1 m1 m2 m3 m4 m5 2>/dev/null || true
    # Remove comdb2test images (base images)
    echo "Cleaning up images..."
    for img in $(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E '^comdb2test:' 2>/dev/null); do
        echo "  Removing $img"
        docker rmi -f "$img" 2>/dev/null || true
    done
    # Remove docker-compose generated images (various naming patterns)
    for img in $(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'docker[-_]?(c1|m[0-9])|^[a-f0-9]+-c1|^[a-f0-9]+-m[0-9]' 2>/dev/null); do
        echo "  Removing $img"
        docker rmi -f "$img" 2>/dev/null || true
    done
    # Remove images by name containing the project patterns
    for img in $(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'client|server' | grep -v -E 'mysql|postgres|redis|mongo' 2>/dev/null); do
        echo "  Removing $img"
        docker rmi -f "$img" 2>/dev/null || true
    done
    # Prune dangling images from build
    echo "Pruning dangling images..."
    docker image prune -f 2>/dev/null || true
    rm -rf common docker-compose.yml 2>/dev/null || true
    echo "Cleanup complete."
    echo ""
    echo "Remaining comdb2-related images (if any):"
    docker images | grep -E 'comdb2|docker.*[cm][0-9]' || echo "  None"
    exit 0
}

if [[ $# -lt 1 ]] || [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
    usage
fi

if [[ "$1" == "--cleanup" ]]; then
    cleanup
fi

testname=$1
shift

numnodes=3
keep=0
coverage=""
nodeprefix="m"

while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--nodes)
            numnodes=$2
            shift 2
            ;;
        -k|--keep)
            keep=1
            shift
            ;;
        --coverage)
            coverage="--coverage"
            shift
            ;;
        *)
            echo "Unknown option: $1"
            usage
            ;;
    esac
done

# Get the script directory and source directory
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
src_dir="$(cd "$script_dir/../.." && pwd)"

# Build cluster node list
cluster=""
for node in $(seq 1 $numnodes); do
    cluster="$cluster ${nodeprefix}${node}"
done
cluster=$(echo $cluster | xargs)  # trim whitespace

echo "========================================"
echo "Running clustered test: $testname"
echo "Cluster nodes: $cluster"
echo "Source directory: $src_dir"
echo "Keep containers: $keep"
echo "========================================"

cd "$script_dir"

# Build the test command (working_dir is set to /comdb2/tests in docker-compose)
# Export CLUSTER before running make to avoid quoting issues with spaces
test_cmd="export CLUSTER='$cluster' && make $testname BUILDDIR=/comdb2/build"

# Build runit arguments
runit_args="-s $src_dir -n $numnodes -c \"$test_cmd\""

if [[ $keep -eq 1 ]]; then
    runit_args="$runit_args --keep"
fi

if [[ -n "$coverage" ]]; then
    runit_args="$runit_args $coverage"
fi

# Run using runit
eval ./runit $runit_args
